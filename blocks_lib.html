<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>run_blocks demo</title>
<style>
  :root {
    --bg: #161a1e; --grid: #24282d; --block-fill: #2b3036; --block-border: #5a646e; --text: #ebf0f5;
  }
  html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font: 16px/1.35 system-ui, Segoe UI, Roboto, Arial; }
  .wrap { max-width: 1200px; margin: 0 auto; padding: 16px; display: grid; gap: 16px; }
  .canvas { background: #111519; border: 1px solid #293039; border-radius: 14px; overflow: hidden; }
  /* give containers explicit heights so the SVG (100%) has room */
  #app1 { height: 620px; }
  #app2 { height: 360px; }
  #app3 { height: 700px; }

  /* Node styling (applies inside each instance) */
  .block rect { fill: var(--block-fill); stroke: var(--block-border); stroke-width: 2; rx: 14; ry: 14; filter: drop-shadow(0 1px 0 rgba(0,0,0,.3)); cursor: grab; }
  .block.dragging rect { cursor: grabbing; }
  .block text { fill: var(--text); font-size: 16px; font-weight: 500; }
  /* optional stroke classes if you want to use className instead of direct color */
  .c-motor   { stroke: rgb(171,71,188); }
  .c-motor2  { stroke: rgb(186,104,200); }
  .c-sens1   { stroke: rgb(77,182,172); }
  .c-sens2   { stroke: rgb(3,169,244); }
  .c-cereb   { stroke: rgb(240,98,146); }
  .c-basal   { stroke: rgb(245,127,23); }
  .c-thal    { stroke: rgb(1,87,155); }
  .c-olf     { stroke: rgb(56,142,60); }
</style>
</head>
<body>
<div class="wrap">
  <h2>run_blocks demo</h2>
  <div id="app1" class="canvas"></div>
  <div id="app2" class="canvas"></div>
  <div id="app3" class="canvas"></div>
</div>

<!-- ======== Drop-in library (IIFE) ======== -->
<script>
(() => {
  const SVG_NS = "http://www.w3.org/2000/svg";
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const uid = (() => { let i = 0; return (p="id") => `${p}-${(++i).toString(36)}`; })();
  const create = (tag, attrs={}, parent=null) => {
    const el = document.createElementNS(SVG_NS, tag);
    for (const [k,v] of Object.entries(attrs)) (k==="textContent") ? (el.textContent=v) : el.setAttribute(k, v);
    if (parent) parent.appendChild(el); return el;
  };
  const parseRGB = (str) => {
    const m = /rgba?\((\d+),\s*(\d+),\s*(\d+)/i.exec(str);
    return m ? [parseInt(m[1],10), parseInt(m[2],10), parseInt(m[3],10)] : [230,235,240];
  };
  const brighten = ([r,g,b], d=30) => `rgb(${Math.min(255,r+d)},${Math.min(255,g+d)},${Math.min(255,b+d)})`;
  const bPoint = (p0,p1,p2,p3,t)=>{ const u=1-t; return {
    x:(u*u*u)*p0.x + 3*(u*u)*t*p1.x + 3*u*(t*t)*p2.x + (t*t*t)*p3.x,
    y:(u*u*u)*p0.y + 3*(u*u)*t*p1.y + 3*u*(t*t)*p2.y + (t*t*t)*p3.y
  }};
  class Block {
    constructor(diagram, id, x,y,w,h, label){
      this.d=diagram; this.id=id; this.x=x; this.y=y; this.w=w; this.h=h; this.label=label;
      this.g = create("g", {class:"block","data-id":id}, this.d.gBlocks);
      this.rect = create("rect", {x,y,width:w,height:h,rx:14,ry:14}, this.g);
      this.text = create("text", {"text-anchor":"middle","dominant-baseline":"middle"}, this.g);
      this._renderText(); this._bindDrag();
    }
    _renderText(){
      this.text.replaceChildren();
      const parts = this.label.replace(/<br\/?>/g,"\n").split("\n");
      const lineH=18, totalH=lineH*parts.length;
      const cx = this.x + this.w/2;
      const y0 = (this.y + this.h/2) - (totalH/2) + 12;
      this.text.setAttribute("x", cx); this.text.setAttribute("y", y0);
      parts.forEach((line,i)=>{ const t=document.createElementNS(SVG_NS,"tspan");
        if(i>0) t.setAttribute("dy", lineH); t.setAttribute("x", cx); t.textContent=line; this.text.appendChild(t); });
    }
    anchor(edge,t){ t=clamp(t,-0.5,0.5);
      if(edge==="top"||edge==="bottom"){
        return { x:this.x + this.w/2 + this.w*t, y: edge==="top" ? this.y : this.y+this.h };
      } else {
        return { x: edge==="left"? this.x : this.x+this.w, y: this.y + this.h/2 + this.h*t };
      }
    }
    edgeDir(edge){ return edge==="top"?{x:0,y:-1}:edge==="right"?{x:1,y:0}:edge==="bottom"?{x:0,y:1}:{x:-1,y:0}; }
    edgeDirInto(edge){ const v=this.edgeDir(edge); return {x:-v.x,y:-v.y}; }
    setPos(x,y){
      this.x=x; this.y=y; this.rect.setAttribute("x",x); this.rect.setAttribute("y",y);
      const parts=this.label.replace(/<br\/?>/g,"\n").split("\n"); const lineH=18, totalH=lineH*parts.length;
      const cx=this.x+this.w/2, y0=(this.y+this.h/2)-(totalH/2)+12;
      this.text.setAttribute("x",cx); this.text.setAttribute("y",y0);
      for(const t of this.text.querySelectorAll("tspan")) t.setAttribute("x",cx);
    }
    _bindDrag(){
      let start=null;
      const down=e=>{ start={x:e.clientX,y:e.clientY,bx:this.x,by:this.y}; this.g.classList.add("dragging"); this.g.setPointerCapture(e.pointerId); };
      const move=e=>{ if(!start) return; this.setPos(start.bx+(e.clientX-start.x), start.by+(e.clientY-start.y)); this.d.update(); };
      const up  =e=>{ start=null; this.g.classList.remove("dragging"); this.g.releasePointerCapture(e.pointerId); };
      this.g.addEventListener("pointerdown",down); this.g.addEventListener("pointermove",move);
      this.g.addEventListener("pointerup",up); this.g.addEventListener("pointercancel",up);
    }
  }
  class Connection {
    constructor(diagram, {start,end,color,className,width=3,sparks=0,sparkSpeed=0.8,emitter=false,maxLive=0,outOffset=4}){
      this.d=diagram; this.start=start; this.end=end; this.width=width; this.color=color; this.className=className;
      this.sparks=Math.max(0,sparks); this.sparkSpeed=Math.max(0,sparkSpeed); this.emitter=!!emitter; this.maxLive=maxLive|0; this.outOffset=outOffset;
      this.live=[]; this.emitAcc=0;
      this.path = create("path", {fill:"none","stroke-width":width,"marker-end":`url(#${this.d.ids.arrow})`}, this.d.gConns);
      // allow either CSS class or color (color may be a palette key)
      if(this.className) this.path.setAttribute("class",this.className);
      if(this.color) {
        const resolved = this.d.resolveColor(this.color);
        if (resolved) this.path.setAttribute("stroke", resolved);
      }
      this.sparkGroup = create("g", {}, this.d.gSparks);
      if(!this.emitter) this.phases=Array.from({length:this.sparks},(_,i)=>i/Math.max(1,this.sparks));
    }
    endpoints(){
      const sb=this.d.blocks[this.start.block], eb=this.d.blocks[this.end.block];
      const p0=sb.anchor(this.start.edge,this.start.t), d0=sb.edgeDir(this.start.edge);
      let p3=eb.anchor(this.end.edge,this.end.t);
      const dOut=eb.edgeDir(this.end.edge), dInto=eb.edgeDirInto(this.end.edge);
      p3={x:p3.x + dOut.x*this.outOffset, y:p3.y + dOut.y*this.outOffset}; // push outside target block
      return {p0,d0,p3,dInto};
    }
    controls(p0,d0,p3,dInto){
      const span=Math.hypot(p3.x-p0.x,p3.y-p0.y);
      const push=Math.min(this.d.const.CONTROL_PUSH_MAX, span*this.d.const.CONTROL_PUSH_RATIO);
      return { c1:{x:p0.x+d0.x*push, y:p0.y+d0.y*push}, c2:{x:p3.x-dInto.x*push, y:p3.y-dInto.y*push} };
    }
    updatePath(){
      const {p0,d0,p3,dInto}=this.endpoints(); const {c1,c2}=this.controls(p0,d0,p3,dInto);
      this.path.setAttribute("d", `M ${p0.x} ${p0.y} C ${c1.x} ${c1.y}, ${c2.x} ${c2.y}, ${p3.x} ${p3.y}`);
      this.cached={p0,c1,c2,p3};
    }
    drawSparks(dt,time){
      if(this.sparks<=0||this.sparkSpeed<=0) return;
      if(!this.cached) this.updatePath(); const {p0,c1,c2,p3}=this.cached;
      this.sparkGroup.replaceChildren();
      const r=Math.max(1,Math.floor((this.width+5)/2)); const stroke=getComputedStyle(this.path).stroke;
      if(!this._sparkColor) this._sparkColor=brighten(parseRGB(stroke),30);
      if(!this.emitter){
        for(const phase of this.phases){ const t=(phase+time*this.sparkSpeed)%1; const pt=bPoint(p0,c1,c2,p3,t);
          create("circle",{cx:pt.x,cy:pt.y,r,fill:this._sparkColor},this.sparkGroup); }
        return;
      }
      const rate=Math.max(0,this.sparks*this.sparkSpeed); this.emitAcc += rate*dt;
      let toSpawn=Math.floor(this.emitAcc); this.emitAcc-=toSpawn; if(Math.random()<this.emitAcc){toSpawn++; this.emitAcc=0;}
      while(toSpawn--){ if(this.maxLive && this.live.length>=this.maxLive) break; this.live.push(0.0); }
      const next=[]; for(let t of this.live){ t+=this.sparkSpeed*dt; if(t<1){ const pt=bPoint(p0,c1,c2,p3,t);
        create("circle",{cx:pt.x,cy:pt.y,r,fill:this._sparkColor},this.sparkGroup); next.push(t);} } this.live=next;
    }
  }
  class Diagram {
    constructor(container, opts={}){
      this.opts=Object.assign({width:1000,height:720,grid:true},opts);
      this.ids={root:uid("diagram"),grid:uid("grid"),arrow:uid("arrow")};
      this.svg = create("svg",{id:this.ids.root,viewBox:`0 0 ${this.opts.width} ${this.opts.height}`,preserveAspectRatio:"xMidYMid meet",width:"100%",height:"100%"},container);
      const defs=create("defs",{},this.svg);
      if(this.opts.grid){ const p=create("pattern",{id:this.ids.grid,width:24,height:24,patternUnits:"userSpaceOnUse"},defs);
        create("path",{d:"M24 0H0V24",fill:"none",stroke:"var(--grid)","stroke-width":"1"},p);
        // Size the grid rect to the viewBox so it never over/underflows when scaling
        create("rect",{x:0,y:0,width:this.opts.width, height:this.opts.height, fill:`url(#${this.ids.grid})`},this.svg); }
      const marker=create("marker",{id:this.ids.arrow,viewBox:"0 0 10 10",refX:"9",refY:"5",markerWidth:"5",markerHeight:"5",orient:"auto-start-reverse"},defs);
      create("polygon",{points:"0,0 10,5 0,10",fill:"context-stroke"},marker);
      // Paint order: blocks (bottom) → connections (above) → sparks (top)
      this.gBlocks=create("g",{class:"blocks"},this.svg);
      this.gConns=create("g",{class:"connections"},this.svg);
      this.gSparks=create("g",{class:"sparks"},this.svg);
      this.blocks={}; this.connections=[]; this._last=performance.now(); this._running=false;
      this.colors={ motor:"rgb(171,71,188)", motor2:"rgb(186,104,200)", sens1:"rgb(77,182,172)", sens2:"rgb(3,169,244)", cereb:"rgb(240,98,146)", basal:"rgb(245,127,23)", thal:"rgb(1,87,155)", olf:"rgb(56,142,60)", arrow:"rgb(230,235,240)" };
      this.const={ CONTROL_PUSH_MAX:320, CONTROL_PUSH_RATIO:0.42 };
    }
    // palette name → CSS color (else return original string)
    resolveColor(v){
      if(!v) return null;
      if(this.colors[v]) return this.colors[v];
      return v;
    }
    addBlock(id,x,y,w,h,label){ const b=new Block(this,id,x,y,w,h,label); this.blocks[id]=b; return b; }
    block(id){ return this.blocks[id]; }
    connect(opts){ const c=new Connection(this,opts); this.connections.push(c); c.updatePath(); return c; }
    update(){ for(const c of this.connections) c.updatePath(); }
    _tick=(now)=>{ if(!this._running) return; const dt=(now-this._last)/1000; this._last=now; const elapsed=now/1000;
      for(const c of this.connections) c.drawSparks(dt,elapsed); requestAnimationFrame(this._tick); };
    start(){ if(this._running) return; this._running=true; this._last=performance.now(); requestAnimationFrame(this._tick); }
    stop(){ this._running=false; }

    /* -------- JSON loader (schema tolerant) -------- */
    loadFromJSON(json){
      // accepts: JS object, JSON string, or <script type="application/json" id="...">
      let data=json;
      if (typeof json==="string") {
        const el = document.getElementById(json);
        if (el && el.tagName==="SCRIPT") data = JSON.parse(el.textContent);
        else data = JSON.parse(json);
      }
      // blocks: support {blocks:[{id,x,y,w/h,width/height,label/text}]} or {nodes:[...]}
      const blocksArr = data.blocks || data.nodes || [];
      for (const b of blocksArr) {
        this.addBlock(b.id ?? b.name, b.x, b.y, b.w ?? b.width, b.h ?? b.height, b.label ?? b.text ?? "");
      }
      // connections: nested {start:{block,edge,t}, end:{...}} or flat keys
      const connsArr = data.connections || data.edges || data.links || [];
      for (const e of connsArr) {
        const start = e.start || { block: e.start_id ?? e.from ?? e.src ?? e.source,
                                   edge:  e.start_edge ?? e.edge_from ?? "right",
                                   t:     e.start_t ?? e.t_from ?? 0 };
        const end   = e.end   || { block: e.end_id   ?? e.to   ?? e.dst ?? e.target,
                                   edge:  e.end_edge   ?? e.edge_to   ?? "left",
                                   t:     e.end_t   ?? e.t_to   ?? 0 };
        const className = e.className ?? e.class ?? undefined;
        let color = e.color ?? e.stroke;
        if (color && this.colors[color]) color = this.colors[color];
        this.connect({
          start, end,
          width: e.width ?? e.stroke_width ?? 3,
          color,
          className,
          sparks: e.sparks ?? e.spark_count ?? 0,
          sparkSpeed: e.spark_speed ?? e.sparkSpeed ?? 0.8,
          emitter: !!(e.emitter ?? e.random ?? false),
          maxLive: e.max_live ?? e.maxLive ?? 0,
          outOffset: e.out_offset ?? e.outOffset ?? 4
        });
      }
      this.update();
    }
  }
  window.run_blocks = (containerSelector, callback, options={})=>{
    const container = (typeof containerSelector==="string") ? document.querySelector(containerSelector) : containerSelector;
    if(!container) throw new Error("run_blocks: container not found");
    const diagram=new Diagram(container, options);
    const b = {
      addBlock:(...a)=>diagram.addBlock(...a),
      block:(id)=>diagram.block(id),
      connect:(o)=>diagram.connect(o),
      update:()=>diagram.update(),
      start:()=>diagram.start(),
      stop:()=>diagram.stop(),
      colors:diagram.colors,
      const:diagram.const,
      svg:diagram.svg,
      loadFromJSON:(j)=>diagram.loadFromJSON(j)
    };
    // optional auto-JSON loading via options
    if (options.json) b.loadFromJSON(options.json);
    if (options.jsonScriptId) b.loadFromJSON(options.jsonScriptId);
    if (options.jsonUrl) {
      fetch(options.jsonUrl).then(r=>r.json()).then(obj=>{ b.loadFromJSON(obj); b.update(); }).catch(console.error);
    }
    if (typeof callback==="function") callback(b);
    diagram.start();
    return b;
  };
})();
</script>
<!-- ======== /library ======== -->

<!-- ======== Example usage ======== -->
<script>
  // Diagram 1 — Neuro flow (your full example)
  run_blocks("#app1", (b) => {
    // blocks
    b.addBlock("A", 390,  30, 220,  80, "Motor Cortex");
    b.addBlock("B", 390, 130, 220,  80, "Corticospinal Tract");
    b.addBlock("C", 360, 230, 280,  80, "Spinal Cord<br/>Lower Motor Neurons");
    b.addBlock("D", 390, 330, 220,  80, "Peripheral Nerves");
    b.addBlock("E", 390, 430, 220,  80, "Muscles");
    b.addBlock("F", 340, 540, 320,  80, "Movement & Sensory Feedback");
    b.addBlock("G",  70, 540, 260,  80, "Spinal Cord Feedback");
    b.addBlock("H", 720, 280, 220, 110, "Thalamus");
    b.addBlock("I",  70, 130, 200,  80, "Pons");
    b.addBlock("J",  70, 230, 200,  80, "Cerebellum");
    b.addBlock("K", 720,  70, 220,  80, "Basal Ganglia");
    b.addBlock("L", 720, 430, 220,  80, "Olfactory Input");

    const c = b.colors;
    // cortex loop
    [["A","B"],["B","C"],["C","D"],["D","E"]].forEach(([s,e])=>{
      b.connect({start:{block:s,edge:"bottom",t:0}, end:{block:e,edge:"top",t:0}, width:3, sparks:3, sparkSpeed:0.8, color:c.motor});
    });
    // sensory feedback
    b.connect({start:{block:"E",edge:"bottom",t:0}, end:{block:"F",edge:"top",t:0}, width:3, sparks:3, sparkSpeed:0.8, color:c.sens1});
    b.connect({start:{block:"F",edge:"left",t:0},  end:{block:"G",edge:"right",t:0}, width:3, sparks:2, sparkSpeed:0.7, color:c.sens2});
    b.connect({start:{block:"F",edge:"right",t:0}, end:{block:"H",edge:"bottom",t:0}, width:3, sparks:2, sparkSpeed:0.7, color:c.sens2});
    // cerebellum loop
    b.connect({start:{block:"A",edge:"left", t:-0.2}, end:{block:"I",edge:"right",t:-0.2}, width:3, sparks:3, sparkSpeed:0.8, color:c.cereb});
    b.connect({start:{block:"I",edge:"bottom",t:0},  end:{block:"J",edge:"top",  t:0},    width:3, sparks:3, sparkSpeed:0.8, color:c.cereb});
    b.connect({start:{block:"J",edge:"right", t:0},  end:{block:"H",edge:"left", t:-0.1}, width:3, sparks:3, sparkSpeed:0.8, color:c.cereb});
    // basal -> thalamus
    b.connect({start:{block:"K",edge:"bottom",t:0}, end:{block:"H",edge:"top",t:0}, width:3, sparks:3, sparkSpeed:0.8, color:c.basal});
    // thalamus -> motor cortex
    b.connect({start:{block:"H",edge:"right",t:0}, end:{block:"A",edge:"right",t:0}, width:3, sparks:4, sparkSpeed:0.9, color:c.thal});
    // olfactory -> motor
    b.connect({start:{block:"L",edge:"left",t:0}, end:{block:"A",edge:"bottom",t:0.3}, width:3, sparks:3, sparkSpeed:0.8, color:c.olf});
  }, { width: 1000, height: 620 });

  // Diagram 2 — tiny toy graph loaded via JSON option
  const app2Spec = {
    "blocks": [
      { "id": "X", "x": 60,  "y": 40, "w": 160, "h": 60, "label": "Input" },
      { "id": "Y", "x": 300, "y": 40, "w": 160, "h": 60, "label": "Processor" },
      { "id": "Z", "x": 540, "y": 40, "w": 160, "h": 60, "label": "Output" }
    ],
    "connections": [
      {
        "start": { "block": "X", "edge": "right", "t": 0 },
        "end":   { "block": "Y", "edge": "left",  "t": 0 },
        "width": 3,
        "sparks": 2,
        "spark_speed": 0.9,
        "color": "motor"
      },
      {
        "start": { "block": "Y", "edge": "right", "t": 0 },
        "end":   { "block": "Z", "edge": "left",  "t": 0 },
        "width": 3,
        "sparks": 2,
        "spark_speed": 0.9,
        "color": "sens2"
      }
    ]
  };

  run_blocks("#app2", null, {
    width: 760,
    height: 360,
    json: app2Spec
  });

  // Diagram 3 — Port of the Python "thalamus/cortex + sensory/motor" scene
  run_blocks("#app3", (b) => {
    // --- Colors (Python palette) ---
    const EAR_COLOR1        = "rgb(27,94,32)";
    const EYE_COLOR1        = "rgb(1,87,155)";
    const SKIN_COLOR1       = "rgb(245,127,23)";

    const EAR_COLOR2        = "rgb(56,142,60)";
    const EYE_COLOR2        = "rgb(2,136,209)";
    const SKIN_COLOR2       = "rgb(251,192,45)";

    const EAR_COLOR3        = "rgb(77,182,172)";
    const EYE_COLOR3        = "rgb(3,169,244)";

    const EYE_EAR_COLOR     = "rgb(79,195,247)";
    const EYE_COLOR4        = "rgb(100,181,246)";

    const MOTOR_AREA_COLOR1 = "rgb(171,71,188)";
    const MOTOR_AREA_COLOR2 = "rgb(186,104,200)";

    const COGNITIVE_COLOR4  = "rgb(136,14,79)";
    const COGNITIVE_COLOR3  = "rgb(194,24,91)";
    const COGNITIVE_COLOR2  = "rgb(233,30,99)";
    const COGNITIVE_COLOR1  = "rgb(240,98,146)";

    const ARROW_COLOR       = b.colors.arrow; // from library palette

    // --- Blocks (coordinates mirror Python layout) ---
    const a = b.addBlock("A", 460,  50, 400, 200, "Thalamus");
    const c1= b.addBlock("B", 330, 360, 100, 400, "Cortex");
    const ear = b.addBlock("Ear", 10,  50, 100, 100, "Ear");
    const skin= b.addBlock("Skin",10, 200, 100, 100, "Skin");
    const eye = b.addBlock("Eye", 10, 350, 100, 100, "Eye");
    const move= b.addBlock("Move",10, 500, 100, 100, "Movement");
    const note1 = b.addBlock("NoteSorted", 560, 300, 200, 100, "Topographically sorted");
    const note2 = b.addBlock("NoteBrain",  610, 690, 280, 100, "Data flow in the human brain");
    // soften note blocks visually
    (note1.rect).setAttribute("opacity","0.35");
    (note2.rect).setAttribute("opacity","0.35");

    // helper for slight randomness like the Python version
    const rnd = () => Math.random();

    // collect connections here (not necessary, but mirrors structure)
    const add = (opts) => b.connect(opts);

    // --- Sensory input: Ear/Eye/Skin/Movement -> Thalamus (left) with offsets & randomized end t ---
    for (const t of [-0.4, 0.0, 0.4]) {
      add({ start:{block:"Ear", edge:"right", t},  end:{block:"A", edge:"left",  t:-0.5 + rnd()}, color: EAR_COLOR1, width:3, sparks:3, sparkSpeed: 0.7 + rnd()/4 });
      add({ start:{block:"Eye", edge:"right", t},  end:{block:"A", edge:"left",  t:-0.5 + rnd()}, color: EYE_COLOR1, width:3, sparks:3, sparkSpeed: 0.7 + rnd()/4 });
      add({ start:{block:"Skin",edge:"right", t},  end:{block:"A", edge:"left",  t:-0.5 + rnd()}, color: SKIN_COLOR1, width:3, sparks:3, sparkSpeed: 0.7 + rnd()/4 });
      add({ start:{block:"Move",edge:"right", t},  end:{block:"A", edge:"left",  t:-0.5 + rnd()}, color: MOTOR_AREA_COLOR1, width:3, sparks:3, sparkSpeed: 0.7 + rnd()/4 });
    }

    // --- Cortex -> Cortex: a few lateral internal edges with random offsets ---
    for (let i=0;i<5;i++){
      add({
        start:{block:"B", edge:"left",  t:-0.5 + rnd()},
        end:  {block:"B", edge:"right", t:-0.5 + rnd()},
        color: ARROW_COLOR, width:3, sparks:3, sparkSpeed: 0.7 + rnd()/4
      });
    }

    // --- Thalamus -> Cortex (15 areas) ---
    const thalToCtxColors = [
      EYE_COLOR1, EYE_COLOR2, EYE_COLOR3, EYE_COLOR4, EYE_EAR_COLOR,
      EAR_COLOR3, EAR_COLOR2, EAR_COLOR1, SKIN_COLOR2, SKIN_COLOR1,
      MOTOR_AREA_COLOR1, COGNITIVE_COLOR1, COGNITIVE_COLOR2, COGNITIVE_COLOR3, COGNITIVE_COLOR4
    ];
    const perArea = 1;
    thalToCtxColors.forEach((col, idx) => {
      const area = idx / 15 + 0.05;
      for (let t=0; t<perArea; t++){
        const lane = 0.5 - (area + t/30);
        add({
          start:{block:"A", edge:"bottom", t: lane},
          end:  {block:"B", edge:"right",  t: lane},
          color: col, width:3, sparks:3, sparkSpeed: 0.7 + rnd()/4
        });
      }
    });

    // --- Cortex -> Thalamus (12 areas) + motor split to Movement ---
    const ctxToThalColors = [
      EYE_COLOR2, EYE_COLOR3, EYE_COLOR4, EYE_EAR_COLOR, EAR_COLOR3, EAR_COLOR2,
      SKIN_COLOR2, MOTOR_AREA_COLOR1, COGNITIVE_COLOR1, COGNITIVE_COLOR2, COGNITIVE_COLOR3, COGNITIVE_COLOR4
    ];
    ctxToThalColors.forEach((col, idx) => {
      const area = idx / 13;
      const lane = 0.4 - (area + 0/26);
      // to thalamus (random end on left side)
      add({
        start:{block:"B", edge:"left",  t: lane},
        end:  {block:"A", edge:"left",  t: -0.5 + rnd()},
        color: col, width:3, sparks:3, sparkSpeed: 0.7 + rnd()/4
      });
      // special motor split: to Movement bottom at two lanes
      if (col === MOTOR_AREA_COLOR1) {
        add({
          start:{block:"B", edge:"left",  t: lane},
          end:  {block:"Move", edge:"bottom", t: -0.33},
          color: MOTOR_AREA_COLOR2, width:3, sparks:3, sparkSpeed: 0.7 + rnd()/4
        });
        add({
          start:{block:"B", edge:"left",  t: lane},
          end:  {block:"Move", edge:"bottom", t: 0.33},
          color: MOTOR_AREA_COLOR2, width:3, sparks:3, sparkSpeed: 0.7 + rnd()/4
        });
      }
    });
  }, { width: 900, height: 800 });
</script>
</body>
</html>
